@C The @{core@} macro contains wrapper functions corresponding
to the header file @{llvm-c/Core.h@} of the LLVM C binding.
@$@<core@>==@{
type Type C.LLVMTypeRef;
type Value C.LLVMValueRef;

@<coreConstants@>
@<Operations on contexts@>
@<Operations on modules@>
@<Operations on integer types@>
@<Operations on function types@>
@<Operations on functions@>
@}

@D The usage of the C constants is really awkward because they are
stongly typed signed integers and we need strongly typed unsigned integers.
A conversion at runtime fails because the constants are defined as literals
in a header file and thus don't exist anymore at runtime.
Thus we redefine the constants.
@$@<coreConstants@>==@{
type CallConv uint;
const (
  CCallConv           = 0;
  FastCallConv        = 8;
  ColdCallConv        = 9;
  X86StdcallCallConv  = 64;
  X86FastcallCallConv = 65;
)


type IntPredicate int;
const (
  IntEQ = 32 + iota; /**< equal */
  IntNE;      /**< not equal */
  IntUGT;     /**< unsigned greater than */
  IntUGE;     /**< unsigned greater or equal */
  IntULT;     /**< unsigned less than */
  IntULE;     /**< unsigned less or equal */
  IntSGT;     /**< signed greater than */
  IntSGE;     /**< signed greater or equal */
  IntSLT;     /**< signed less than */
  IntSLE;     /**< signed less or equal */
)
@}


@D A LLVM context simply exists for thread safety.
It allows parallel compilation of independent LLVM modules.

We will just work with the global LLVM context for a long time.
@$@<Operations on contexts@>==@{
type Context C.LLVMContextRef;

@<ContextCreate@>
@<GetGlobalContext@>
@}

@E
@$@<ContextCreate@>==@{
func ContextCreate() Context {
  return Context(C.LLVMContextCreate());
}
@}

@E
@$@<GetGlobalContext@>==@{
func GetGlobalContext() Context {
  return Context(C.LLVMGetGlobalContext());
}
@}


@D LLVM modules correspond nicely to diamonds packages and contain mainly
a symbol table and a list of functions.
@$@<Operations on modules@>==@{
type Module C.LLVMModuleRef;

@<ModuleCreateWithName@>
@<ModuleCreateWithNameInContext@>
@<DisposeModule@>
@<DumpModule@>
@}

@E Create a LLVM module with the given name and the global LLVM context.
@$@<ModuleCreateWithName@>==@{
func ModuleCreateWithName(moduleId string) Module {
    var mod C.LLVMModuleRef;
    callWithString(func(s *C.char){ mod = C.LLVMModuleCreateWithName(s); },
                   moduleId);
    return Module(mod);
}
@}

@E Create a LLVM module with the given name and LLVM context.
@$@<ModuleCreateWithNameInContext@>==@{
func ModuleCreateWithNameInContext(moduleId string, llvmCtx Context)
       Module {
    var mod C.LLVMModuleRef;
    callWithString(func(s *C.char){
        mod = C.LLVMModuleCreateWithNameInContext(s, C.LLVMContextRef(llvmCtx));
    }, moduleId);
    return Module(mod);
}
@}

@E Deletes the given LLVM module and frees the memory used by it.
@$@<DisposeModule@>==@{
func DisposeModule(llvmModule Module) {
  C.LLVMDisposeModule(C.LLVMModuleRef(llvmModule));
}
@}

@E Print the given module in LLVM assembly language to standard output.
This is especially nice for debugging problems.
@$@<DumpModule@>==@{
func DumpModule(llvmModule Module) {
  C.LLVMDumpModule(C.LLVMModuleRef(llvmModule));
}
@}


@D LLVM supports arbitrary integer types.
They can range from 1 bit up to any number of bits.
The compiler doesn't support the whole flexibility and we
don't want to make use of it.

1 Bit integers are used as booleans by LLVM.
We support only 64 bit integers first but plan to introduce
8, 16, 24, 32 and 48 bit integers later.
@$@<Operations on integer types@>==@{
func Int1TypeInContext(ctx Context) Type {
    return Type(C.LLVMInt1TypeInContext(C.LLVMContextRef(ctx)));
}

func Int8TypeInContext(ctx Context) Type {
    return Type(C.LLVMInt8TypeInContext(C.LLVMContextRef(ctx)));
}

func Int16TypeInContext(ctx Context) Type {
    return Type(C.LLVMInt16TypeInContext(C.LLVMContextRef(ctx)));
}

func Int32TypeInContext(ctx Context) Type {
    return Type(C.LLVMInt32TypeInContext(C.LLVMContextRef(ctx)));
}

func Int64TypeInContext(ctx Context) Type {
    return Type(C.LLVMInt64TypeInContext(C.LLVMContextRef(ctx)));
}

func IntTypeInContext(ctx Context, numBits uint) Type {
    return Type(C.LLVMIntTypeInContext(C.LLVMContextRef(ctx),
                                       C.unsigned(numBits)));
}


func Int1Type() Type {
    return Type(C.LLVMInt1Type());
}

func Int8Type() Type {
    return Type(C.LLVMInt8Type());
}

func Int16Type() Type {
    return Type(C.LLVMInt16Type());
}

func Int32Type() Type {
    return Type(C.LLVMInt32Type());
}

func Int64Type() Type {
    return Type(C.LLVMInt64Type());
}

func IntType(numBits uint) Type {
    return Type(C.LLVMIntType(C.unsigned(numBits)));
}


func GetIntTypeWidth(intType Type) uint {
    return uint(C.LLVMGetIntTypeWidth(C.LLVMTypeRef(intType)));
}
@}


@D LLVM supports function types.
So functions can be first class types.
@$@<Operations on function types@>==@{
func FunctionType(returnType Type, paramTypes []Type, isVarArg bool) Type {
    paramCnt := len(paramTypes);
    params := make([]C.LLVMTypeRef, paramCnt);
    for i:=0; i < paramCnt; i++ {
        params[i] = C.LLVMTypeRef(paramTypes[i]);
    }
    isvarg := 0;
    if isVarArg { isvarg = 1; }
    return Type(C.LLVMFunctionType(C.LLVMTypeRef(returnType),
                                   &params[0], C.unsigned(paramCnt),
                                   C.int(isvarg)));
}

func IsFunctionVarArg(functionType Type) bool {
    return int(C.LLVMIsFunctionVarArg(C.LLVMTypeRef(functionType))) != 0;
}

func GetReturnType(functionType Type) Type {
    return Type(C.LLVMGetReturnType(C.LLVMTypeRef(functionType)));
}

func CountParamTypes(functionType Type) uint {
    return uint(C.LLVMCountParamTypes(C.LLVMTypeRef(functionType)));
}
@}


@D LLVM supports function types.
So functions can be first class types.
@$@<Operations on functions@>==@{
func AddFunction(mod Module, funcName string, functionType Type) Value {
    var ret Value;
    callWithString(func(s *C.char){
        ret = Value(C.LLVMAddFunction(C.LLVMModuleRef(mod), s,
                                C.LLVMTypeRef(functionType)));
    }, funcName);
    return ret;
}

/*
LLVMValueRef LLVMGetNamedFunction(LLVMModuleRef M, const char *Name);
LLVMValueRef LLVMGetFirstFunction(LLVMModuleRef M);
LLVMValueRef LLVMGetLastFunction(LLVMModuleRef M);
LLVMValueRef LLVMGetNextFunction(LLVMValueRef Fn);
LLVMValueRef LLVMGetPreviousFunction(LLVMValueRef Fn);
void LLVMDeleteFunction(LLVMValueRef Fn);
unsigned LLVMGetIntrinsicID(LLVMValueRef Fn);
unsigned LLVMGetFunctionCallConv(LLVMValueRef Fn);
void LLVMSetFunctionCallConv(LLVMValueRef Fn, unsigned CC);
const char *LLVMGetGC(LLVMValueRef Fn);
void LLVMSetGC(LLVMValueRef Fn, const char *Name);
*/
@}
