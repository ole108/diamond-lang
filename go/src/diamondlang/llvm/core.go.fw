@C The @{core@} macro contains wrapper functions corresponding
to the header file @{llvm-c/Core.h@} of the LLVM C binding.
@$@<core@>==@{
type Type C.LLVMTypeRef;
type Value C.LLVMValueRef;

@<coreConstants@>
@<Operations on contexts@>
@<Operations on modules@>
@<Operations on integer types@>
@<Operations on function types@>
@<Operations on functions@>
@<Operations on parameters@>
@}

@D The usage of the C constants is really awkward because they are
stongly typed signed integers and we need strongly typed unsigned integers.
A conversion at runtime fails because the constants are defined as literals
in a header file and thus don't exist anymore at runtime.
Thus we redefine the constants.
@$@<coreConstants@>==@{
type CallConv uint;
const (
  CCallConv           = 0;
  FastCallConv        = 8;
  ColdCallConv        = 9;
  X86StdcallCallConv  = 64;
  X86FastcallCallConv = 65;
)


type IntPredicate int;
const (
  IntEQ = 32 + iota; /**< equal */
  IntNE;      /**< not equal */
  IntUGT;     /**< unsigned greater than */
  IntUGE;     /**< unsigned greater or equal */
  IntULT;     /**< unsigned less than */
  IntULE;     /**< unsigned less or equal */
  IntSGT;     /**< signed greater than */
  IntSGE;     /**< signed greater or equal */
  IntSLT;     /**< signed less than */
  IntSLE;     /**< signed less or equal */
)
@}


@D A LLVM context simply exists for thread safety.
It allows parallel compilation of independent LLVM modules.

We will just work with the global LLVM context for a long time.
@$@<Operations on contexts@>==@{
type Context C.LLVMContextRef;

@<ContextCreate@>
@<GetGlobalContext@>
@}

@E
@$@<ContextCreate@>==@{
func ContextCreate() Context {
  return Context(C.LLVMContextCreate());
}
@}

@E
@$@<GetGlobalContext@>==@{
func GetGlobalContext() Context {
  return Context(C.LLVMGetGlobalContext());
}
@}


@D LLVM modules correspond nicely to diamonds packages and contain mainly
a symbol table and a list of functions.
@$@<Operations on modules@>==@{
type Module C.LLVMModuleRef;

@<ModuleCreateWithName@>
@<ModuleCreateWithNameInContext@>
@<DisposeModule@>
@<DumpModule@>
@}

@E Create a LLVM module with the given name and the global LLVM context.
@$@<ModuleCreateWithName@>==@{
func ModuleCreateWithName(moduleId string) Module {
    var mod C.LLVMModuleRef;
    callWithString(func(s *C.char){ mod = C.LLVMModuleCreateWithName(s); },
                   moduleId);
    return Module(mod);
}
@}

@E Create a LLVM module with the given name and LLVM context.
@$@<ModuleCreateWithNameInContext@>==@{
func ModuleCreateWithNameInContext(moduleId string, llvmCtx Context)
       Module {
    var mod C.LLVMModuleRef;
    callWithString(func(s *C.char){
        mod = C.LLVMModuleCreateWithNameInContext(s, C.LLVMContextRef(llvmCtx));
    }, moduleId);
    return Module(mod);
}
@}

@E Deletes the given LLVM module and frees the memory used by it.
@$@<DisposeModule@>==@{
func DisposeModule(llvmModule Module) {
  C.LLVMDisposeModule(C.LLVMModuleRef(llvmModule));
}
@}

@E Print the given module in LLVM assembly language to standard output.
This is especially nice for debugging problems.
@$@<DumpModule@>==@{
func DumpModule(llvmModule Module) {
  C.LLVMDumpModule(C.LLVMModuleRef(llvmModule));
}
@}


@D LLVM supports arbitrary integer types.
They can range from 1 bit up to any number of bits.
The compiler doesn't support the whole flexibility and we
don't want to make use of it.

1 Bit integers are used as booleans by LLVM.
We support only 64 bit integers first but plan to introduce
8, 16, 24, 32 and 48 bit integers later.
@$@<Operations on integer types@>==@{
func Int1TypeInContext(ctx Context) Type {
    return Type(C.LLVMInt1TypeInContext(C.LLVMContextRef(ctx)));
}

func Int8TypeInContext(ctx Context) Type {
    return Type(C.LLVMInt8TypeInContext(C.LLVMContextRef(ctx)));
}

func Int16TypeInContext(ctx Context) Type {
    return Type(C.LLVMInt16TypeInContext(C.LLVMContextRef(ctx)));
}

func Int32TypeInContext(ctx Context) Type {
    return Type(C.LLVMInt32TypeInContext(C.LLVMContextRef(ctx)));
}

func Int64TypeInContext(ctx Context) Type {
    return Type(C.LLVMInt64TypeInContext(C.LLVMContextRef(ctx)));
}

func IntTypeInContext(ctx Context, numBits uint) Type {
    return Type(C.LLVMIntTypeInContext(C.LLVMContextRef(ctx),
                                       C.unsigned(numBits)));
}


func Int1Type() Type {
    return Type(C.LLVMInt1Type());
}

func Int8Type() Type {
    return Type(C.LLVMInt8Type());
}

func Int16Type() Type {
    return Type(C.LLVMInt16Type());
}

func Int32Type() Type {
    return Type(C.LLVMInt32Type());
}

func Int64Type() Type {
    return Type(C.LLVMInt64Type());
}

func IntType(numBits uint) Type {
    return Type(C.LLVMIntType(C.unsigned(numBits)));
}


func GetIntTypeWidth(intType Type) uint {
    return uint(C.LLVMGetIntTypeWidth(C.LLVMTypeRef(intType)));
}
@}


@D LLVM supports function types.
So functions can be first class types.
@$@<Operations on function types@>==@{
func FunctionType(returnType Type, paramTypes []Type, isVarArg bool) Type {
    paramCnt := len(paramTypes);
    params := make([]C.LLVMTypeRef, paramCnt);
    for i:=0; i < paramCnt; i++ {
        params[i] = C.LLVMTypeRef(paramTypes[i]);
    }
    isvarg := 0;
    if isVarArg { isvarg = 1; }
    return Type(C.LLVMFunctionType(C.LLVMTypeRef(returnType),
                                   &params[0], C.unsigned(paramCnt),
                                   C.int(isvarg)));
}

func IsFunctionVarArg(functionType Type) bool {
    return int(C.LLVMIsFunctionVarArg(C.LLVMTypeRef(functionType))) != 0;
}

func GetReturnType(functionType Type) Type {
    return Type(C.LLVMGetReturnType(C.LLVMTypeRef(functionType)));
}

func CountParamTypes(functionType Type) uint {
    return uint(C.LLVMCountParamTypes(C.LLVMTypeRef(functionType)));
}
@}


@D LLVM supports function types.
So functions can be first class types.
@$@<Operations on functions@>==@{
func AddFunction(mod Module, funcName string, functionType Type) Value {
    var ret Value;
    callWithString(func(s *C.char){
        ret = Value(C.LLVMAddFunction(C.LLVMModuleRef(mod), s,
                                C.LLVMTypeRef(functionType)));
    }, funcName);
    return ret;
}

func GetNamedFunction(mod Module, funcName string) Value {
    var ret Value;
    callWithString(func(s *C.char){
        ret = Value(C.LLVMGetNamedFunction(C.LLVMModuleRef(mod), s));
    }, funcName);
    return ret;
}

func GetFirstFunction(mod Module) Value {
    return Value(C.LLVMGetFirstFunction(C.LLVMModuleRef(mod)));
}

func GetLastFunction(mod Module) Value {
    return Value(C.LLVMGetLastFunction(C.LLVMModuleRef(mod)));
}

func GetNextFunction(fun Value) Value {
    return Value(C.LLVMGetNextFunction(C.LLVMValueRef(fun)));
}

func GetPreviousFunction(fun Value) Value {
    return Value(C.LLVMGetPreviousFunction(C.LLVMValueRef(fun)));
}

func DeleteFunction(fun Value) {
    C.LLVMDeleteFunction(C.LLVMValueRef(fun));
}

func GetIntrinsicID(fun Value) uint {
    return uint(C.LLVMGetIntrinsicID(C.LLVMValueRef(fun)));
}

func GetFunctionCallConv(fun Value) CallConv {
    return CallConv(C.LLVMGetFunctionCallConv(C.LLVMValueRef(fun)));
}

func SetFunctionCallConv(fun Value, callConv CallConv) {
    C.LLVMSetFunctionCallConv(C.LLVMValueRef(fun), C.unsigned(callConv));
}

func GetGC(fun Value) string {
    return C.GoString(C.LLVMGetGC(C.LLVMValueRef(fun)));
}

func SetGC(fun Value, gcName string) {
    callWithString(func(s *C.char){
        C.LLVMSetGC(C.LLVMValueRef(fun), s);
    }, gcName);
}
@}


@D LLVM operations on function parameters.
@$@<Operations on parameters@>==@{
func CountParams(fun Value) uint {
    return uint(C.LLVMCountParams(C.LLVMValueRef(fun)));
}


func GetParams(fun Value) []Value {
    tmp := make([]C.LLVMValueRef, CountParams(fun));
    C.LLVMGetParams(C.LLVMValueRef(fun), &tmp[0]);
    ret := make([]Value, len(tmp));
    for i := 0; i < len(tmp); i++ {
        ret[i] = Value(tmp[i]);
    }
    return ret;
}

func GetParam(fun Value, idx uint) Value {
    return Value(C.LLVMGetParam(C.LLVMValueRef(fun), C.unsigned(idx)));
}

func GetParamParent(inst Value) Value {
    return Value(C.LLVMGetParamParent(C.LLVMValueRef(inst)));
}

func GetFirstParam(fun Value) Value {
    return Value(C.LLVMGetFirstParam(C.LLVMValueRef(fun)));
}

func GetLastParam(fun Value) Value {
    return Value(C.LLVMGetLastParam(C.LLVMValueRef(fun)));
}

func GetNextParam(arg Value) Value {
    return Value(C.LLVMGetNextParam(C.LLVMValueRef(arg)));
}

func GetPreviousParam(arg Value) Value {
    return Value(C.LLVMGetPreviousParam(C.LLVMValueRef(arg)));
}

func SetParamAlignment(arg Value, align uint) {
    C.LLVMSetParamAlignment(C.LLVMValueRef(arg), C.unsigned(align));
}
@}

