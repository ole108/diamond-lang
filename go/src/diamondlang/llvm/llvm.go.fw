@B@<Package llvm@>
The llvm package builds an interface to the Low Level Virtual Machine (LLVM)
that is used for code generation.

Specifically this package contains wrapper functions for accessing the
LLVM C binding.
The header files for the C binding can be found at:
@{/usr/include/llvm-c/@}

@/Please Note:@/ The wrapper functions have the same name as the C binding
functions except we leave the 'LLVM' prefix out since go supports packages.

We have a simple C example for a start: ~/work/llvm/*.c


The file @{llvm.go@} contains the wrapper functions for accessing the
LLVM C binding.
@O@<llvm/llvm.go@>==@{@-
package llvm

/*
// Headers required by LLVM
#include <llvm-c/Core.h>
#include <llvm-c/Analysis.h>
#include <llvm-c/ExecutionEngine.h>
#include <llvm-c/Target.h>
#include <llvm-c/Transforms/Scalar.h>

// General stuff
#include <stdlib.h>
*/
import "C"
import "unsafe"
import "fmt"
import "os"

@<constants@>

@<dirtyTestFunc@>

@<Initialisation and utility functions@>
@<Operations on modules@>
@<Operations on contexts@>
@}


The file @{llvm_test.go@} contains tests for the LLVM interface.
@O@<llvm/llvm_test.go@>==@{@-
package llvm

import (
  "testing";
  "fmt";
)

func TestFirst(t *testing.T) {
  dirtyTestFunc(6);
}

func TestLlvm(t *testing.T) {
  fmt.Println("LinkInJIT");
  LinkInJIT();

  fmt.Println("InitializeNativeTarget");
  InitializeNativeTarget();

  fmt.Println("ModuleCreateWithNameInContext");
  llvmMod := ModuleCreateWithNameInContext("tstMod", GetGlobalContext());

  fmt.Println("DumpModule");
  DumpModule(llvmMod);

  fmt.Println("DisposeModule");
  DisposeModule(llvmMod);

  if (false) { t.Error("The LLVM interface doesn't work!"); }
}
@}


@C Define constants for different calling conventions.
The usage of the C constants is really awkward because they are stongly typed
signed integers and we need strongly typed unsigned integers.
A conversion at runtime fails because the constants are defined as literals
in a header file and thus don't exist anymore at runtime.
@$@<constants@>==@{
type CallConv uint;
const (
  CCallConv           = 0;
  FastCallConv        = 8;
  ColdCallConv        = 9;
  X86StdcallCallConv  = 64;
  X86FastcallCallConv = 65;
)


type IntPredicate int;
const (
  IntEQ = 32 + iota; /**< equal */
  IntNE;      /**< not equal */
  IntUGT;     /**< unsigned greater than */
  IntUGE;     /**< unsigned greater or equal */
  IntULT;     /**< unsigned less than */
  IntULE;     /**< unsigned less or equal */
  IntSGT;     /**< signed greater than */
  IntSGE;     /**< signed greater or equal */
  IntSLT;     /**< signed less than */
  IntSLE;     /**< signed less or equal */
)


type VerifierFailureAction int
const (
  AbortProcessAction = iota; /* verifier will print to stderr and abort() */
  PrintMessageAction;        /* verifier will print to stderr and return 1 */
  ReturnStatusAction;        /* verifier will just return 1 */
)
@}


@C
@$@<dirtyTestFunc@>==@{
func dirtyTestFunc(num int) {
  LinkInJIT();
  InitializeNativeTarget();
  llvmMod := ModuleCreateWithNameInContext("tstMod", GetGlobalContext());

  fac_args := [...]C.LLVMTypeRef{ C.LLVMInt32Type() };
  pStr := C.CString("fac");
  var fac C.LLVMValueRef = C.LLVMAddFunction(C.LLVMModuleRef(llvmMod), pStr,
            C.LLVMFunctionType(C.LLVMInt32Type(), &fac_args[0], 1, 0));
  C.free(unsafe.Pointer(pStr));
  C.LLVMSetFunctionCallConv(fac, C.uint(CCallConv));
  var n C.LLVMValueRef = C.LLVMGetParam(fac, 0);

  pStr = C.CString("entry");
  var entry C.LLVMBasicBlockRef = C.LLVMAppendBasicBlock(fac, pStr);
  C.free(unsafe.Pointer(pStr));
  pStr = C.CString("iftrue");
  var iftrue C.LLVMBasicBlockRef = C.LLVMAppendBasicBlock(fac, pStr);
  C.free(unsafe.Pointer(pStr));
  pStr = C.CString("iffalse");
  var iffalse C.LLVMBasicBlockRef = C.LLVMAppendBasicBlock(fac, pStr);
  C.free(unsafe.Pointer(pStr));
  pStr = C.CString("end");
  var end C.LLVMBasicBlockRef = C.LLVMAppendBasicBlock(fac, pStr);
  C.free(unsafe.Pointer(pStr));
  var builder C.LLVMBuilderRef = C.LLVMCreateBuilder();

  C.LLVMPositionBuilderAtEnd(builder, entry);
  pStr = C.CString("n == 0");
  var If C.LLVMValueRef = C.LLVMBuildICmp(builder,
             C.LLVMIntPredicate(IntEQ), n,
             C.LLVMConstInt(C.LLVMInt32Type(), 0, 0), pStr);
  C.free(unsafe.Pointer(pStr));
  C.LLVMBuildCondBr(builder, If, iftrue, iffalse);

  C.LLVMPositionBuilderAtEnd(builder, iftrue);
  var res_iftrue C.LLVMValueRef = C.LLVMConstInt(C.LLVMInt32Type(), 1, 0);
  C.LLVMBuildBr(builder, end);

  C.LLVMPositionBuilderAtEnd(builder, iffalse);
  pStr = C.CString("n - 1");
  var n_minus C.LLVMValueRef = C.LLVMBuildSub(builder, n,
                  C.LLVMConstInt(C.LLVMInt32Type(), 1, 0), pStr);
  C.free(unsafe.Pointer(pStr));
  call_fac_args := [...]C.LLVMValueRef{ n_minus };
  pStr = C.CString("fac(n - 1)");
  var call_fac C.LLVMValueRef = C.LLVMBuildCall(builder, fac,
                   &call_fac_args[0], 1, pStr);
  C.free(unsafe.Pointer(pStr));
  pStr = C.CString("n * fac(n - 1)");
  var res_iffalse C.LLVMValueRef = C.LLVMBuildMul(builder, n, call_fac, pStr);
  C.free(unsafe.Pointer(pStr));
  C.LLVMBuildBr(builder, end);

  C.LLVMPositionBuilderAtEnd(builder, end);
  pStr = C.CString("result");
  var res C.LLVMValueRef = C.LLVMBuildPhi(builder, C.LLVMInt32Type(), pStr);
  C.free(unsafe.Pointer(pStr));
  phi_vals := [...]C.LLVMValueRef{ res_iftrue, res_iffalse };
  phi_blocks := [...]C.LLVMBasicBlockRef{ iftrue, iffalse };
  C.LLVMAddIncoming(res, &phi_vals[0], &phi_blocks[0], 2);
  C.LLVMBuildRet(builder, res);

  var error *C.char = nil;
  C.LLVMVerifyModule(C.LLVMModuleRef(llvmMod),
                     C.LLVMVerifierFailureAction(AbortProcessAction),
                     &error);
  // Handler == LLVMAbortProcessAction -> No need to check errors:
  C.LLVMDisposeMessage(error);

  var engine C.LLVMExecutionEngineRef;
  var provider C.LLVMModuleProviderRef =
          C.LLVMCreateModuleProviderForExistingModule(C.LLVMModuleRef(llvmMod));
  error = nil;
  if C.LLVMCreateJITCompiler(&engine, provider, 2, &error) != 0 {
    fmt.Fprintln(os.Stderr, C.GoString(error));
    C.LLVMDisposeMessage(error);
    os.Exit(1);
  }

  DumpModule(llvmMod);
  // Optimizations:
  fmt.Println("\n\nOptimizing:");
  var pass C.LLVMPassManagerRef = C.LLVMCreatePassManager();
  C.LLVMAddTargetData(C.LLVMGetExecutionEngineTargetData(engine), pass);
  C.LLVMAddConstantPropagationPass(pass);
  C.LLVMAddInstructionCombiningPass(pass);
  C.LLVMAddPromoteMemoryToRegisterPass(pass);
  // Demotes every possible value to memory:
  C.LLVMAddDemoteMemoryToRegisterPass(pass);
  C.LLVMAddGVNPass(pass);
  C.LLVMAddCFGSimplificationPass(pass);
  C.LLVMRunPassManager(pass, C.LLVMModuleRef(llvmMod));
  DumpModule(llvmMod);

  fmt.Println("");
  fmt.Printf("Running fac(%d) with JIT...\n", num);
  exec_args := [...]C.LLVMGenericValueRef{ C.LLVMCreateGenericValueOfInt(
                        C.LLVMInt32Type(), C.ulonglong(num), 0) };
  var exec_res C.LLVMGenericValueRef =
                   C.LLVMRunFunction(engine, fac, 1, &exec_args[0]);
  fmt.Println("Result:", C.LLVMGenericValueToInt(exec_res, 0));

  C.LLVMDisposeExecutionEngine(engine);
  C.LLVMDisposeBuilder(builder);
  C.LLVMDisposePassManager(pass);
//DisposeModule(llvmMod);  // Throws assertion!!! :-(((

  fmt.Println("Survived: ALL");
}
@}


@C
@$@<Initialisation and utility functions@>==@{
@<LinkIns@>
@<InitializeNativeTarget@>
@}

@D You can choose to link in the JIT (Just In Time compiler) or
the interpreter for LLVM.
@$@<LinkIns@>==@{
func LinkInInterpreter() {
  C.LLVMLinkInInterpreter();
}

func LinkInJIT() {
  C.LLVMLinkInJIT();
}
@}

@D A LLVM target is a platform like X86 or ARM.
This little functions initializes LLVM to use the right one.
This is needed for the JIT.
@$@<InitializeNativeTarget@>==@{
func InitializeNativeTarget() {
  C.LLVMInitializeNativeTarget();
}
@}


@C A LLVM context simply exists for thread safety.
It allows parallel compilation of independent LLVM modules.

We will just work with the global LLVM context for a long time.
@$@<Operations on contexts@>==@{
type LlvmContext C.LLVMContextRef;

@<ContextCreate@>
@<GetGlobalContext@>
@<ContextDispose@>
@}

@D
@$@<ContextCreate@>==@{
func ContextCreate() LlvmContext {
  return LlvmContext(C.LLVMContextCreate());
}
@}

@D
@$@<GetGlobalContext@>==@{
func GetGlobalContext() LlvmContext {
  return LlvmContext(C.LLVMGetGlobalContext());
}
@}

@D
@$@<ContextDispose@>==@{
func ContextDispose(llvmCtx LlvmContext) {
  C.LLVMDisposeModule(C.LLVMContextRef(llvmCtx));
}
@}

@C LLVM modules correspond nicely to diamonds packages and contain mainly
a symbol table and a list of functions.
@$@<Operations on modules@>==@{
type LlvmModule C.LLVMModuleRef;

@<ModuleCreateWithName@>
@<ModuleCreateWithNameInContext@>
@<DisposeModule@>
@<DumpModule@>
@}

@D Create a LLVM module with the given name and the global LLVM context.
@$@<ModuleCreateWithName@>==@{
func ModuleCreateWithName(moduleId string) LlvmModule {
  p := C.CString(moduleId);
  mod := C.LLVMModuleCreateWithName(p);
  C.free(unsafe.Pointer(p));
  return LlvmModule(mod);
}
@}

@D Create a LLVM module with the given name and LLVM context.
@$@<ModuleCreateWithNameInContext@>==@{
func ModuleCreateWithNameInContext(moduleId string, llvmCtx LlvmContext)
       LlvmModule {
  p := C.CString(moduleId);
  mod := C.LLVMModuleCreateWithNameInContext(p, C.LLVMContextRef(llvmCtx));
  C.free(unsafe.Pointer(p));
  return LlvmModule(mod);
}
@}

@D Deletes the given LLVM module and frees the memory used by it.
@$@<DisposeModule@>==@{
func DisposeModule(llvmModule LlvmModule) {
  C.LLVMDisposeModule(C.LLVMModuleRef(llvmModule));
}
@}

@D Deletes the given LLVM module and frees the memory used by it.
@$@<DumpModule@>==@{
func DumpModule(llvmModule LlvmModule) {
  C.LLVMDumpModule(C.LLVMModuleRef(llvmModule));
}
@}

