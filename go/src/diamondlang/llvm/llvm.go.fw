@B@<Package llvm@>
The llvm package builds an interface to the Low Level Virtual Machine (LLVM)
that is used for code generation.

Specifically this package contains wrapper functions for accessing the
LLVM C binding.
The header files for the C binding can be found at:
@{/usr/include/llvm-c/@}

We have a simple C example for a start: ~/work/llvm/*.c


@/Please Note:@/ The wrapper functions have the same name as the C binding
functions except we leave the 'LLVM' prefix out since go supports packages.


The file @{llvm.go@} contains the wrapper functions for accessing the
LLVM C binding.
@O@<llvm/llvm.go@>==@{@-
package llvm

/*
// Headers required by LLVM
#include <llvm-c/Core.h>
#include <llvm-c/Analysis.h>
#include <llvm-c/ExecutionEngine.h>
#include <llvm-c/Target.h>
#include <llvm-c/Transforms/Scalar.h>

// General stuff
#include <stdlib.h>
*/
import "C"
import "unsafe"
import "fmt"
import "os"

@<Utility functions@>

// Macros corresponding to C header files:
@<core@>
@<executionEngine@>
@<target@>
@<analysis@>

@<dirtyTestFunc@>
@}


@C
The file @{llvm_test.go@} contains tests for the LLVM interface.
@O@<llvm/llvm_test.go@>==@{@-
package llvm

import (
  "testing";
  "fmt";
)

func TestFirst(t *testing.T) {
  dirtyTestFunc(6);
}

func TestLlvm(t *testing.T) {
  fmt.Println("LinkInJIT");
  LinkInJIT();

  fmt.Println("InitializeNativeTarget");
  InitializeNativeTarget();

  fmt.Println("ModuleCreateWithNameInContext");
  llvmMod := ModuleCreateWithNameInContext("tstMod", GetGlobalContext());

  fmt.Println("DumpModule");
  DumpModule(llvmMod);

  fmt.Println("DisposeModule");
  DisposeModule(llvmMod);

  if (false) { t.Error("The LLVM interface doesn't work!"); }
}
@}



@C
@$@<dirtyTestFunc@>==@{
func dirtyTestFunc(num int) {
  LinkInJIT();
  InitializeNativeTarget();
  llvmMod := ModuleCreateWithNameInContext("tstMod", GetGlobalContext());

  fac_args := []Type{ Int32Type() };
  fac  := AddFunction(llvmMod, "fac",
                      FunctionType(Int32Type(), fac_args, false));
  C.LLVMSetFunctionCallConv(C.LLVMTypeRef(fac), C.uint(CCallConv));
  var n C.LLVMValueRef = C.LLVMGetParam(C.LLVMTypeRef(fac), 0);

  pStr := C.CString("entry");
  var entry C.LLVMBasicBlockRef = C.LLVMAppendBasicBlock(C.LLVMTypeRef(fac),
                                     pStr);
  C.free(unsafe.Pointer(pStr));
  pStr = C.CString("iftrue");
  var iftrue C.LLVMBasicBlockRef = C.LLVMAppendBasicBlock(C.LLVMTypeRef(fac),
                                      pStr);
  C.free(unsafe.Pointer(pStr));
  pStr = C.CString("iffalse");
  var iffalse C.LLVMBasicBlockRef = C.LLVMAppendBasicBlock(C.LLVMTypeRef(fac),
                                      pStr);
  C.free(unsafe.Pointer(pStr));
  pStr = C.CString("end");
  var end C.LLVMBasicBlockRef = C.LLVMAppendBasicBlock(C.LLVMTypeRef(fac),
                                      pStr);
  C.free(unsafe.Pointer(pStr));
  var builder C.LLVMBuilderRef = C.LLVMCreateBuilder();

  C.LLVMPositionBuilderAtEnd(builder, entry);
  pStr = C.CString("n == 0");
  var If C.LLVMValueRef = C.LLVMBuildICmp(builder,
             C.LLVMIntPredicate(IntEQ), n,
             C.LLVMConstInt(C.LLVMInt32Type(), 0, 0), pStr);
  C.free(unsafe.Pointer(pStr));
  C.LLVMBuildCondBr(builder, If, iftrue, iffalse);

  C.LLVMPositionBuilderAtEnd(builder, iftrue);
  var res_iftrue C.LLVMValueRef = C.LLVMConstInt(C.LLVMInt32Type(), 1, 0);
  C.LLVMBuildBr(builder, end);

  C.LLVMPositionBuilderAtEnd(builder, iffalse);
  pStr = C.CString("n - 1");
  var n_minus C.LLVMValueRef = C.LLVMBuildSub(builder, n,
                  C.LLVMConstInt(C.LLVMInt32Type(), 1, 0), pStr);
  C.free(unsafe.Pointer(pStr));
  call_fac_args := [...]C.LLVMValueRef{ n_minus };
  pStr = C.CString("fac(n - 1)");
  var call_fac C.LLVMValueRef = C.LLVMBuildCall(builder, C.LLVMTypeRef(fac),
                   &call_fac_args[0], 1, pStr);
  C.free(unsafe.Pointer(pStr));
  pStr = C.CString("n * fac(n - 1)");
  var res_iffalse C.LLVMValueRef = C.LLVMBuildMul(builder, n, call_fac, pStr);
  C.free(unsafe.Pointer(pStr));
  C.LLVMBuildBr(builder, end);

  C.LLVMPositionBuilderAtEnd(builder, end);
  pStr = C.CString("result");
  var res C.LLVMValueRef = C.LLVMBuildPhi(builder, C.LLVMInt32Type(), pStr);
  C.free(unsafe.Pointer(pStr));
  phi_vals := [...]C.LLVMValueRef{ res_iftrue, res_iffalse };
  phi_blocks := [...]C.LLVMBasicBlockRef{ iftrue, iffalse };
  C.LLVMAddIncoming(res, &phi_vals[0], &phi_blocks[0], 2);
  C.LLVMBuildRet(builder, res);

  var error *C.char = nil;
  C.LLVMVerifyModule(C.LLVMModuleRef(llvmMod),
                     C.LLVMVerifierFailureAction(AbortProcessAction),
                     &error);
  // Handler == LLVMAbortProcessAction -> No need to check errors:
  C.LLVMDisposeMessage(error);

  var engine C.LLVMExecutionEngineRef;
  var provider C.LLVMModuleProviderRef =
          C.LLVMCreateModuleProviderForExistingModule(C.LLVMModuleRef(llvmMod));
  error = nil;
  if C.LLVMCreateJITCompiler(&engine, provider, 2, &error) != 0 {
    fmt.Fprintln(os.Stderr, C.GoString(error));
    C.LLVMDisposeMessage(error);
    os.Exit(1);
  }

//  DumpModule(llvmMod);
  // Optimizations:
  fmt.Println("\n\nOptimizing:");
  var pass C.LLVMPassManagerRef = C.LLVMCreatePassManager();
  C.LLVMAddTargetData(C.LLVMGetExecutionEngineTargetData(engine), pass);
  C.LLVMAddConstantPropagationPass(pass);
  C.LLVMAddInstructionCombiningPass(pass);
  C.LLVMAddPromoteMemoryToRegisterPass(pass);
  // Demotes every possible value to memory:
  C.LLVMAddDemoteMemoryToRegisterPass(pass);
  C.LLVMAddGVNPass(pass);
  C.LLVMAddCFGSimplificationPass(pass);
  C.LLVMRunPassManager(pass, C.LLVMModuleRef(llvmMod));
  DumpModule(llvmMod);

  fmt.Println("");
  fmt.Printf("Running fac(%d) with JIT...\n", num);
  exec_args := [...]C.LLVMGenericValueRef{ C.LLVMCreateGenericValueOfInt(
                        C.LLVMInt32Type(), C.ulonglong(num), 0) };
  var exec_res C.LLVMGenericValueRef = C.LLVMRunFunction(engine,
                                         C.LLVMTypeRef(fac), 1, &exec_args[0]);
  fmt.Println("Result:", C.LLVMGenericValueToInt(exec_res, 0));

  C.LLVMDisposeExecutionEngine(engine);
  C.LLVMDisposeBuilder(builder);
  C.LLVMDisposePassManager(pass);
//DisposeModule(llvmMod);  // Throws assertion!!! :-(((

  fmt.Println("Survived: ALL");
}
@}


@C
@$@<Utility functions@>==@{
@<CallStringFunc@>
@}

@D Call the given function (usually a closure) with the given string
argument. This utility function simply handles the conversion to  a
C string and the deletion of the memory for the C string.
@$@<CallStringFunc@>==@{
func callWithString(strFunc func(s *C.char), s string) {
  p := C.CString(s);
  strFunc(p);
  C.free(unsafe.Pointer(p));
}
@}


@i llvm/core.go.fw

@i llvm/executionEngine.go.fw

@i llvm/target.go.fw

@i llvm/analysis.go.fw
